// SPDX-FileCopyrightText: 2021 Open Networking Foundation <info@opennetworking.org>
// SPDX-FileCopyrightText: 2024 Canonical Ltd
// SPDX-License-Identifier: Apache-2.0

/*
 * Connectivity Service Configuration
 *
 * APIs to configure connectivity service in Aether Network
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configapi

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"github.com/omec-project/webconsole/backend/logger"
	"github.com/omec-project/webconsole/configmodels"
	"github.com/omec-project/webconsole/dbadapter"
	"go.mongodb.org/mongo-driver/bson"
)

const (
	devGroupDataColl = "webconsoleData.snapshots.devGroupData"
	sliceDataColl    = "webconsoleData.snapshots.sliceData"
	amDataColl       = "subscriptionData.provisionedData.amData"
	smDataColl       = "subscriptionData.provisionedData.smData"
	smfSelDataColl   = "subscriptionData.provisionedData.smfSelectionSubscriptionData"
	amPolicyDataColl = "policyData.ues.amData"
	smPolicyDataColl = "policyData.ues.smData"
	authSubsDataColl = "subscriptionData.authenticationData.authenticationSubscription"
)

// GetDeviceGroups godoc
//
// @Description  Return the list of device groups
// @Tags         Device Groups
// @Produce      json
// @Security     BearerAuth
// @Success      200  {array}   string  "List of device group names"
// @Failure      401  {object}  nil     "Authorization failed"
// @Failure      403  {object}  nil     "Forbidden"
// @Failure      500  {object}  nil     "Error retrieving device groups"
// @Router       /config/v1/device-group/  [get]
func GetDeviceGroups(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Device Groups")

	deviceGroups := make([]string, 0)
	rawDeviceGroups, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(devGroupDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Warnln(errGetMany)
	}
	for _, rawDeviceGroup := range rawDeviceGroups {
		deviceGroups = append(deviceGroups, rawDeviceGroup["group-name"].(string))
	}

	c.JSON(http.StatusOK, deviceGroups)
}

// GetDeviceGroupByName godoc
//
// @Description  Return the device group
// @Tags         Device Groups
// @Param        deviceGroupName    path    string    true    " "
// @Produce      json
// @Security     BearerAuth
// @Success      200  {object}  configmodels.DeviceGroups  "Device group"
// @Failure      401  {object}  nil                        "Authorization failed"
// @Failure      403  {object}  nil                        "Forbidden"
// @Failure      404  {object}  nil                        "Device group not found"
// @Failure      500  {object}  nil                        "Error retrieving device group"
// @Router       /config/v1/device-group/{deviceGroupName}  [get]
func GetDeviceGroupByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Device Group by name")

	var deviceGroup configmodels.DeviceGroups
	filter := bson.M{"group-name": c.Param("group-name")}
	rawDeviceGroup, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(devGroupDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	err := json.Unmarshal(configmodels.MapToByte(rawDeviceGroup), &deviceGroup)
	if err != nil {
		logger.WebUILog.Errorf("failed to unmarshal device group error: %+v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve device group"})
		return
	}
	if deviceGroup.DeviceGroupName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, deviceGroup)
	}
}

// DeviceGroupGroupNameDelete godoc
//
// @Description  Delete an existing device group
// @Tags         Device Groups
// @Param        deviceGroupName    path    string    true    " "
// @Security     BearerAuth
// @Success      200  {object}  nil  "Device group deleted successfully"
// @Failure      400  {object}  nil  "Bad request"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      500  {object}  nil  "Device Group Deletion Failed"
// @Router       /config/v1/device-group/{deviceGroupName}  [delete]
func DeviceGroupGroupNameDelete(c *gin.Context) {
	requestID := uuid.New().String()
	logger.WebUILog.Debugln("DeviceGroupGroupNameDelete")
	groupName, ok := c.Params.Get("group-name")
	if !ok {
		logger.ConfigLog.Errorf("group-name parameter is missing in the request: %s", requestID)
		c.JSON(http.StatusBadRequest, gin.H{
			"error":      "group-name parameter is missing",
			"request_id": requestID,
		})
		return
	}
	logger.WebUILog.Debugf("Request ID: %s Attempting to delete device group: %s", requestID, groupName)
	if err := deviceGroupDeleteHelper(groupName); err != nil {
		logger.WebUILog.Errorf("Request ID: %s Device group delete failed: %+v", requestID, err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":      fmt.Sprintf("Failed to delete device group %s with error: %+v.", groupName, err),
			"request_id": requestID,
			"message":    "Please refer to the log with the provided Request ID for details.",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// DeviceGroupGroupNamePut -
func DeviceGroupGroupNamePut(c *gin.Context) {
	requestID := uuid.New().String()
	logger.WebUILog.Debugln("DeviceGroupGroupNamePut")
	groupName, ok := c.Params.Get("group-name")
	if !ok {
		logger.ConfigLog.Errorf("group-name parameter is missing in the request: %s", requestID)
		c.JSON(http.StatusBadRequest, gin.H{
			"error":      "group-name parameter is missing",
			"request_id": requestID,
		})
		return
	}
	if !isValidName(groupName) {
		logger.ConfigLog.Errorf("Request ID: %s invalid Device Group name %s. Name needs to match regular expression: %s", requestID, groupName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid Device Group name %s. Name needs to match regular expression: %s",
				groupName, NAME_PATTERN,
			),
			"request_id": requestID,
		})
		return
	}
	var requestDeviceGroup configmodels.DeviceGroups

	ct := c.GetHeader("Content-Type")
	if ct == "" {
		err := "missing Content-Type header"
		logger.ConfigLog.Errorln(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err, "request_id": requestID})
		return
	}

	ct = strings.Split(ct, ";")[0]
	if ct != "application/json" {
		err := fmt.Sprintf("unsupported content-type: %s", ct)
		logger.ConfigLog.Errorln(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err, "request_id": requestID})
		return
	}

	if err := c.ShouldBindJSON(&requestDeviceGroup); err != nil {
		err = fmt.Errorf("JSON bind error: %w", err)
		logger.ConfigLog.Errorln(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error(), "request_id": requestID})
		return
	}

	if statusCode, err := deviceGroupPostHelper(requestDeviceGroup, configmodels.Put_op, groupName); err != nil {
		logger.WebUILog.Errorf("Device group update failed: %+v", err)
		c.JSON(statusCode, gin.H{
			"error":      fmt.Sprintf("Failed to update device group %s with error: %+v.", groupName, err),
			"request_id": requestID,
			"message":    "Please refer to the log with the provided Request ID for details.",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// DeviceGroupGroupNamePost godoc
//
// @Description  Create a new device group
// @Tags         Device Groups
// @Param        deviceGroupName    path    string                       true    " "
// @Param        content            body    configmodels.DeviceGroups    true    " "
// @Security     BearerAuth
// @Success      200  {object}  nil  "Device group created"
// @Failure      400  {object}  nil  "Invalid device group content"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      500  {object}  nil  "Error creating device group"
// @Router       /config/v1/device-group/{deviceGroupName}  [post]
func DeviceGroupGroupNamePost(c *gin.Context) {
	// TODO: Return 409 if device group already exists
	requestID := uuid.New().String()
	logger.WebUILog.Debugln("DeviceGroupGroupNamePost")
	groupName, ok := c.Params.Get("group-name")
	if !ok {
		logger.ConfigLog.Errorf("group-name parameter is missing in the request: %s", requestID)
		c.JSON(http.StatusBadRequest, gin.H{
			"error":      "group-name parameter is missing",
			"request_id": requestID,
		})
		return
	}
	if !isValidName(groupName) {
		logger.ConfigLog.Errorf("invalid Device Group name %s. Name needs to match regular expression: %s", groupName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid Device Group name %s. Name needs to match regular expression: %s",
				groupName, NAME_PATTERN,
			),
			"request_id": requestID,
		})
		return
	}
	var requestDeviceGroup configmodels.DeviceGroups

	ct := c.GetHeader("Content-Type")
	if ct == "" {
		err := "missing Content-Type header"
		logger.ConfigLog.Errorln(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err, "request_id": requestID})
		return
	}

	ct = strings.Split(ct, ";")[0]
	if ct != "application/json" {
		err := fmt.Sprintf("unsupported content-type: %s", ct)
		logger.ConfigLog.Errorln(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err, "request_id": requestID})
		return
	}

	if err := c.ShouldBindJSON(&requestDeviceGroup); err != nil {
		err = fmt.Errorf("JSON bind error: %w", err)
		logger.ConfigLog.Errorln(err)
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error(), "request_id": requestID})
		return
	}

	if statusCode, err := deviceGroupPostHelper(requestDeviceGroup, configmodels.Post_op, groupName); err != nil {
		logger.WebUILog.Errorf("Device group create failed: %+v", err)
		c.JSON(statusCode, gin.H{
			"error":      fmt.Sprintf("Failed to create device group %s with error: %+v.", groupName, err),
			"request_id": requestID,
			"message":    "Please refer to the log with the provided Request ID for details",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// GetNetworkSlices godoc
//
// @Description  Return the list of network slices
// @Tags         Network Slices
// @Produce      json
// @Security     BearerAuth
// @Success      200  {array}   string  "List of network slice names"
// @Failure      401  {object}  nil     "Authorization failed"
// @Failure      403  {object}  nil     "Forbidden"
// @Failure      500  {object}  nil     "Error retrieving network slices"
// @Router       /config/v1/network-slice/  [get]
func GetNetworkSlices(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Network Slices")
	networkSlices := make([]string, 0)

	rawNetworkSlices, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(sliceDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Errorln(errGetMany)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch slices"})
		return
	}

	for _, rawNetworkSlice := range rawNetworkSlices {
		if name, ok := rawNetworkSlice["slice-name"].(string); ok && name != "" {
			networkSlices = append(networkSlices, name)
		} else {
			logger.WebUILog.Warnf("Skipping invalid or missing slice-name field: %+v", rawNetworkSlice)
		}
	}

	c.JSON(http.StatusOK, networkSlices)
}

// GetNetworkSliceByName godoc
//
// @Description  Return the network slice
// @Tags         Network Slices
// @Produce      json
// @Param        sliceName    path    string    true    " "
// @Security     BearerAuth
// @Success      200  {object}  configmodels.Slice  "Network slice"
// @Failure      401  {object}  nil                 "Authorization failed"
// @Failure      403  {object}  nil                 "Forbidden"
// @Failure      404  {object}  nil                 "Network slices not found"
// @Failure      500  {object}  nil                 "Error retrieving network slice"
// @Router       /config/v1/network-slice/{sliceName}  [get]
func GetNetworkSliceByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Network Slice by name")
	var networkSlice configmodels.Slice
	filter := bson.M{"slice-name": c.Param("slice-name")}
	rawNetworkSlice, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(sliceDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	err := json.Unmarshal(configmodels.MapToByte(rawNetworkSlice), &networkSlice)
	if err != nil {
		logger.WebUILog.Errorf("failed to unmarshal network slice error: %+v", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to retrieve network slice"})
		return
	}
	if networkSlice.SliceName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, networkSlice)
	}
}

// NetworkSliceSliceNameDelete godoc
//
// @Description  Delete an existing network slice
// @Tags         Network Slices
// @Produce      json
// @Param        sliceName    path    string    true    " "
// @Security     BearerAuth
// @Success      202  {object}  nil  "Network slice deleted successfully"
// @Failure      400  {object}  nil  "Invalid network slice name provided"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      500  {object}  nil  "Error deleting network slice"
// @Router      /config/v1/network-slice/{sliceName}  [delete]
func NetworkSliceSliceNameDelete(c *gin.Context) {
	logger.WebUILog.Debugln("Received NetworkSliceSliceNameDelete")
	requestID := uuid.New().String()
	sliceName, ok := c.Params.Get("slice-name")
	if !ok {
		logger.ConfigLog.Errorf("slice-name parameter is missing in the request: %s", requestID)
		c.JSON(http.StatusBadRequest, gin.H{
			"error":      "slice-name parameter is missing",
			"request_id": requestID,
		})
		return
	}
	if !isValidName(sliceName) {
		logger.ConfigLog.Errorf("invalid Network Slice name %s. Name needs to match regular expression: %s", sliceName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid slice name %s. Name needs to match regular expression: %s",
				sliceName, NAME_PATTERN,
			),
			"request_id": requestID,
		})
		return
	}
	if err := networkSliceDeleteHelper(sliceName); err != nil {
		logger.WebUILog.Errorf("Network slice delete failed: %+v", err)
		c.JSON(http.StatusInternalServerError, gin.H{
			"error":      fmt.Sprintf("Failed to delete network slice %s with error: %+v.", sliceName, err),
			"request_id": requestID,
			"message":    "Please refer to the log with the provided Request ID for details",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// NetworkSliceSliceNamePost godoc
//
// @Description  Create a new network slice
// @Tags         Network Slices
// @Param        sliceName    path    string                true    " "
// @Param        content      body    configmodels.Slice    true    " "
// @Security     BearerAuth
// @Success      200  {object}  nil  "Network slice created"
// @Failure      400  {object}  nil  "Invalid network slice content"
// @Failure      401  {object}  nil  "Authorization failed"
// @Failure      403  {object}  nil  "Forbidden"
// @Failure      500  {object}  nil  "Error creating network slice"
// @Router       /config/v1/network-slice/{sliceName}  [post]
func NetworkSliceSliceNamePost(c *gin.Context) {
	// TODO: Return 409 if network slices already exist
	logger.ConfigLog.Debugln("Received NetworkSliceSliceNamePost")
	requestID := uuid.New().String()
	sliceName, ok := c.Params.Get("slice-name")
	if !ok {
		logger.ConfigLog.Errorf("slice-name parameter is missing in the request: %s", requestID)
		c.JSON(http.StatusBadRequest, gin.H{
			"error":      "slice-name parameter is missing",
			"request_id": requestID,
		})
		return
	}
	if !isValidName(sliceName) {
		logger.ConfigLog.Errorf("invalid Network Slice name %s. Name needs to match regular expression: %s", sliceName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid slice name %s. Name needs to match regular expression: %s",
				sliceName, NAME_PATTERN,
			),
			"request_id": requestID,
		})
		return
	}
	statusCode, err := networkSlicePostHelper(c, configmodels.Post_op, sliceName)
	if err != nil {
		c.JSON(statusCode, gin.H{
			"error":      fmt.Sprintf("Failed to create network slice %s with error: %+v", sliceName, err),
			"request_id": requestID,
			"message":    "Please refer to the log with the provided Request ID for details",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}

// NetworkSliceSliceNamePut -
func NetworkSliceSliceNamePut(c *gin.Context) {
	logger.ConfigLog.Debugln("Received NetworkSliceSliceNamePut")
	requestID := uuid.New().String()
	sliceName, ok := c.Params.Get("slice-name")
	if !ok {
		logger.ConfigLog.Errorf("slice-name parameter is missing in the request: %s", requestID)
		c.JSON(http.StatusBadRequest, gin.H{
			"error":      "slice-name parameter is missing",
			"request_id": requestID,
		})
		return
	}
	if !isValidName(sliceName) {
		logger.ConfigLog.Errorf("invalid Network Slice name %s. Name needs to match regular expression: %s", sliceName, NAME_PATTERN)
		c.JSON(http.StatusBadRequest, gin.H{
			"error": fmt.Sprintf(
				"Invalid slice name %s. Name needs to match regular expression: %s",
				sliceName, NAME_PATTERN,
			),
			"request_id": requestID,
		})
		return
	}
	statusCode, err := networkSlicePostHelper(c, configmodels.Put_op, sliceName)
	if err != nil {
		c.JSON(statusCode, gin.H{
			"error":      fmt.Sprintf("Failed to update network slice %s with error: %+v.", sliceName, err),
			"request_id": requestID,
			"message":    "Please refer to the log with the provided Request ID for details",
		})
		return
	}
	c.JSON(http.StatusOK, gin.H{})
}
