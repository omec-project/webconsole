// SPDX-FileCopyrightText: 2021 Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0
//

/*
 * Connectivity Service Configuration
 *
 * APIs to configure connectivity service in Aether Network
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configapi

import (
	"encoding/json"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/omec-project/MongoDBLibrary"
	"github.com/omec-project/webconsole/backend/logger"
	"github.com/omec-project/webconsole/configmodels"
	"go.mongodb.org/mongo-driver/bson"
)

const (
	devGroupDataColl = "webconsoleData.snapshots.devGroupData"
	sliceDataColl    = "webconsoleData.snapshots.sliceData"
)

var (
	RestfulAPIGetMany = MongoDBLibrary.RestfulAPIGetMany
	RestfulAPIGetOne  = MongoDBLibrary.RestfulAPIGetOne
)

// GetDeviceGroups -
func GetDeviceGroups(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Device Groups")

	var deviceGroups []string = make([]string, 0)
	rawDeviceGroups := RestfulAPIGetMany(devGroupDataColl, bson.M{})
	for _, rawDeviceGroup := range rawDeviceGroups {
		deviceGroups = append(deviceGroups, rawDeviceGroup["group-name"].(string))
	}

	c.JSON(http.StatusOK, deviceGroups)
}

// GetDeviceGroupsByName -
func GetDeviceGroupByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Device Group by name")

	var deviceGroup configmodels.DeviceGroups
	filter := bson.M{"group-name": c.Param("group-name")}
	rawDeviceGroup := RestfulAPIGetOne(devGroupDataColl, filter)
	json.Unmarshal(mapToByte(rawDeviceGroup), &deviceGroup)

	if deviceGroup.DeviceGroupName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, deviceGroup)
	}
}

// DeviceGroupGroupNameDelete -
func DeviceGroupGroupNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNameDelete")
	if ret := DeviceGroupDeleteHandler(c); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePut -
func DeviceGroupGroupNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePut")
	if ret := DeviceGroupPostHandler(c, configmodels.Put_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePatch -
func DeviceGroupGroupNamePatch(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePatch")
	c.JSON(http.StatusOK, gin.H{})
}

// DeviceGroupGroupNamePost -
func DeviceGroupGroupNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePost")
	if ret := DeviceGroupPostHandler(c, configmodels.Post_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// GetNetworkSlices -
func GetNetworkSlices(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Network Slices")

	var networkSlices []string = make([]string, 0)
	rawNetworkSlices := RestfulAPIGetMany(sliceDataColl, bson.M{})
	for _, rawNetworkSlice := range rawNetworkSlices {
		networkSlices = append(networkSlices, rawNetworkSlice["SliceName"].(string))
	}

	c.JSON(http.StatusOK, networkSlices)
}

// GetNetworkSliceByName -
func GetNetworkSliceByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Network Slice by name")

	var networkSlice configmodels.Slice
	filter := bson.M{"SliceName": c.Param("slice-name")}
	rawNetworkSlice := RestfulAPIGetOne(sliceDataColl, filter)
	json.Unmarshal(mapToByte(rawNetworkSlice), &networkSlice)

	if networkSlice.SliceName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, networkSlice)
	}
}

// NetworkSliceSliceNameDelete -
func NetworkSliceSliceNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNameDelete ")
	if ret := NetworkSliceDeleteHandler(c); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// NetworkSliceSliceNamePost -
func NetworkSliceSliceNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePost ")
	if ret := NetworkSlicePostHandler(c, configmodels.Post_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// NetworkSliceSliceNamePut -
func NetworkSliceSliceNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePut ")
	if ret := NetworkSlicePostHandler(c, configmodels.Put_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}
