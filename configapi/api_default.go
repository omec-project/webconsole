// SPDX-FileCopyrightText: 2021 Open Networking Foundation <info@opennetworking.org>
//
// SPDX-License-Identifier: Apache-2.0
//

/*
 * Connectivity Service Configuration
 *
 * APIs to configure connectivity service in Aether Network
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configapi

import (
	"encoding/json"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/omec-project/webconsole/backend/logger"
	"github.com/omec-project/webconsole/configmodels"
	"go.mongodb.org/mongo-driver/bson"
)

const (
	devGroupDataColl = "webconsoleData.snapshots.devGroupData"
	sliceDataColl    = "webconsoleData.snapshots.sliceData"
)

type MongoManyGetter interface {
	RestfulAPIGetMany(collName string, filter bson.M) ([]map[string]interface{}, error)
}

type MongoOneGetter interface {
	RestfulAPIGetOne(collName string, filter bson.M) (map[string]interface{}, error)
}

// GetDeviceGroups -
func GetDeviceGroups(m MongoManyGetter) gin.HandlerFunc {
	return func(c *gin.Context) {
		setCorsHeader(c)
		logger.WebUILog.Infoln("Get all Device Groups")

		var deviceGroups = make([]string, 0)
		rawDeviceGroups, _ := m.RestfulAPIGetMany(devGroupDataColl, bson.M{})
		for _, rawDeviceGroup := range rawDeviceGroups {
			deviceGroups = append(deviceGroups, rawDeviceGroup["group-name"].(string))
		}

		c.JSON(http.StatusOK, deviceGroups)
	}
}

// GetDeviceGroupsByName -
func GetDeviceGroupByName(m MongoOneGetter) gin.HandlerFunc {
	return func(c *gin.Context) {
		setCorsHeader(c)
		logger.WebUILog.Infoln("Get Device Group by name")

		var deviceGroup configmodels.DeviceGroups
		filter := bson.M{"group-name": c.Param("group-name")}
		rawDeviceGroup, _ := m.RestfulAPIGetOne(devGroupDataColl, filter)
		json.Unmarshal(mapToByte(rawDeviceGroup), &deviceGroup)

		if deviceGroup.DeviceGroupName == "" {
			c.JSON(http.StatusNotFound, nil)
		} else {
			c.JSON(http.StatusOK, deviceGroup)
		}
	}
}

// DeviceGroupGroupNamePut -
func DeviceGroupGroupNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePut")
	if ret := DeviceGroupPostHandler(c, configmodels.Put_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePatch -
func DeviceGroupGroupNamePatch(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePatch")
	c.JSON(http.StatusOK, gin.H{})
}

// DeviceGroupGroupNameDelete -
func DeviceGroupGroupNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNameDelete")
	if ret := DeviceGroupDeleteHandler(c); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePost -
func DeviceGroupGroupNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePost")
	if ret := DeviceGroupPostHandler(c, configmodels.Post_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// GetNetworkSlices -
func GetNetworkSlices(m MongoManyGetter) gin.HandlerFunc {
	return func(c *gin.Context) {
		setCorsHeader(c)
		logger.WebUILog.Infoln("Get all Network Slices")

		var networkSlices []string = make([]string, 0)
		rawNetworkSlices, _ := m.RestfulAPIGetMany(sliceDataColl, bson.M{})
		for _, rawNetworkSlice := range rawNetworkSlices {
			networkSlices = append(networkSlices, rawNetworkSlice["SliceName"].(string))
		}

		c.JSON(http.StatusOK, networkSlices)
	}
}

// GetNetworkSliceByName -
func GetNetworkSliceByName(m MongoOneGetter) gin.HandlerFunc {
	return func(c *gin.Context) {
		setCorsHeader(c)
		logger.WebUILog.Infoln("Get Network Slice by name")

		var networkSlice configmodels.Slice
		filter := bson.M{"SliceName": c.Param("slice-name")}
		rawNetworkSlice, _ := m.RestfulAPIGetOne(sliceDataColl, filter)
		json.Unmarshal(mapToByte(rawNetworkSlice), &networkSlice)

		if networkSlice.SliceName == "" {
			c.JSON(http.StatusNotFound, nil)
		} else {
			c.JSON(http.StatusOK, networkSlice)
		}
	}
}

// NetworkSliceSliceNameDelete -
func NetworkSliceSliceNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNameDelete ")
	if ret := NetworkSliceDeleteHandler(c); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// NetworkSliceSliceNamePost -
func NetworkSliceSliceNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePost ")
	if ret := NetworkSlicePostHandler(c, configmodels.Post_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// NetworkSliceSliceNamePut -
func NetworkSliceSliceNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePut ")
	if ret := NetworkSlicePostHandler(c, configmodels.Put_op); ret == true {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}
