// SPDX-FileCopyrightText: 2021 Open Networking Foundation <info@opennetworking.org>
// SPDX-FileCopyrightText: 2024 Canonical Ltd
// SPDX-License-Identifier: Apache-2.0

/*
 * Connectivity Service Configuration
 *
 * APIs to configure connectivity service in Aether Network
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package configapi

import (
	"encoding/json"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/omec-project/webconsole/backend/logger"
	"github.com/omec-project/webconsole/configmodels"
	"github.com/omec-project/webconsole/dbadapter"
	"go.mongodb.org/mongo-driver/bson"
)

const (
	devGroupDataColl = "webconsoleData.snapshots.devGroupData"
	sliceDataColl    = "webconsoleData.snapshots.sliceData"
)

// GetDeviceGroups godoc
//
//	@Description	Return the list of device groups
//	@Tags			Device Groups
//	@Produce		json
//	@Security 		BearerAuth
//	@Success		200	{array}		string	"List of device group names"
//	@Failure		401	{object}	nil		"Authorization failed"
//	@Failure		403	{object}	nil		"Forbidden"
//	@Failure		500	{object}	nil		"Error retrieving device groups"
//	@Router			/config/v1/device-group/	[get]
func GetDeviceGroups(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Device Groups")

	var deviceGroups []string = make([]string, 0)
	rawDeviceGroups, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(devGroupDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Warnln(errGetMany)
	}
	for _, rawDeviceGroup := range rawDeviceGroups {
		deviceGroups = append(deviceGroups, rawDeviceGroup["group-name"].(string))
	}

	c.JSON(http.StatusOK, deviceGroups)
}

// GetDeviceGroupByName godoc
//
//	@Description	Return the device group
//	@Tags			Device Groups
//	@Param			deviceGroupName	path	string	true	" "
//	@Produce		json
//	@Security 		BearerAuth
//	@Success		200	{object}	configmodels.DeviceGroups	"Device group"
//	@Failure		401	{object}	nil							"Authorization failed"
//	@Failure		403	{object}	nil							"Forbidden"
//	@Failure		404	{object}	nil							"Device group not found"
//	@Failure		500	{object}	nil							"Error retrieving device group"
//	@Router			/config/v1/device-group/{deviceGroupName}	[get]
func GetDeviceGroupByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Device Group by name")

	var deviceGroup configmodels.DeviceGroups
	filter := bson.M{"group-name": c.Param("group-name")}
	rawDeviceGroup, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(devGroupDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	json.Unmarshal(configmodels.MapToByte(rawDeviceGroup), &deviceGroup)

	if deviceGroup.DeviceGroupName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, deviceGroup)
	}
}

// DeviceGroupGroupNameDelete godoc
//
//	@Description	Delete an existing device group
//	@Tags			Device Groups
//	@Param			deviceGroupName	path	string	true	" "
//	@Security		BearerAuth
//	@Success		200	{object}	nil	"Device group deleted successfully"
//	@Failure		400	{object}	nil	"Invalid device group name provided"
//	@Failure		401	{object}	nil	"Authorization failed"
//	@Failure		403	{object}	nil	"Forbidden"
//	@Failure		500	{object}	nil	"Error deleting device group"
//	@Router			/config/v1/device-group/{deviceGroupName}	[delete]
func DeviceGroupGroupNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNameDelete")
	if ret := DeviceGroupDeleteHandler(c); ret {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePut -
func DeviceGroupGroupNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePut")
	if ret := DeviceGroupPostHandler(c, configmodels.Put_op); ret {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// DeviceGroupGroupNamePatch -
func DeviceGroupGroupNamePatch(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePatch")
	c.JSON(http.StatusOK, gin.H{})
}

// DeviceGroupGroupNamePost godoc
//
//	@Description	Create a new device group
//	@Tags			Device Groups
//	@Param			deviceGroupName	path	string						true	" "
//	@Param			content			body	configmodels.DeviceGroups	true	" "
//	@Security		BearerAuth
//	@Success		200	{object}	nil	"Device group created"
//	@Failure		400	{object}	nil	"Invalid device group content"
//	@Failure		401	{object}	nil	"Authorization failed"
//	@Failure		403	{object}	nil	"Forbidden"
//	@Failure		500	{object}	nil	"Error creating device group"
//	@Router			/config/v1/device-group/{deviceGroupName}	[post]
func DeviceGroupGroupNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("DeviceGroupGroupNamePost")
	if ret := DeviceGroupPostHandler(c, configmodels.Post_op); ret {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// GetNetworkSlices godoc
//
//	@Description	Return the list of network slices
//	@Tags			Network Slices
//	@Produce		json
//	@Security 		BearerAuth
//	@Success		200	{array}		string	"List of network slice names"
//	@Failure		401	{object}	nil		"Authorization failed"
//	@Failure		403	{object}	nil		"Forbidden"
//	@Failure		500	{object}	nil		"Error retrieving network slices"
//	@Router			/config/v1/network-slice/	[get]
func GetNetworkSlices(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get all Network Slices")

	var networkSlices []string = make([]string, 0)
	rawNetworkSlices, errGetMany := dbadapter.CommonDBClient.RestfulAPIGetMany(sliceDataColl, bson.M{})
	if errGetMany != nil {
		logger.DbLog.Warnln(errGetMany)
	}
	for _, rawNetworkSlice := range rawNetworkSlices {
		networkSlices = append(networkSlices, rawNetworkSlice["SliceName"].(string))
	}

	c.JSON(http.StatusOK, networkSlices)
}

// GetNetworkSliceByName godoc
//
// @Description	Return the network slice
// @Tags			Network Slices
// @Produce		json
// @Param			sliceName	path	string	true	" "
// @Security		BearerAuth
// @Success		200	{object}	configmodels.Slice	"Network slice"
// @Failure		401	{object}	nil					"Authorization failed"
// @Failure		403	{object}	nil					"Forbidden"
// @Failure		404	{object}	nil					"Network slices not found"
// @Failure		500	{object}	nil					"Error retrieving network slice"
// @Router		/config/v1/network-slice/{sliceName}	[get]
func GetNetworkSliceByName(c *gin.Context) {
	setCorsHeader(c)
	logger.WebUILog.Infoln("Get Network Slice by name")

	var networkSlice configmodels.Slice
	filter := bson.M{"SliceName": c.Param("slice-name")}
	rawNetworkSlice, errGetOne := dbadapter.CommonDBClient.RestfulAPIGetOne(sliceDataColl, filter)
	if errGetOne != nil {
		logger.DbLog.Warnln(errGetOne)
	}
	json.Unmarshal(configmodels.MapToByte(rawNetworkSlice), &networkSlice)

	if networkSlice.SliceName == "" {
		c.JSON(http.StatusNotFound, nil)
	} else {
		c.JSON(http.StatusOK, networkSlice)
	}
}

// NetworkSliceSliceNameDelete godoc
//
// @Description	Delete an existing network slice
// @Tags			Network Slices
// @Produce		json
// @Param			sliceName	path	string	true	" "
// @Security 		BearerAuth
// @Success		202	{object}	nil	"Network slice deleted successfully"
// @Failure		400	{object}	nil	"Invalid network slice name provided"
// @Failure		401	{object}	nil	"Authorization failed"
// @Failure		403	{object}	nil	"Forbidden"
// @Failure		500	{object}	nil	"Error deleting network slice"
// @Router			/config/v1/network-slice/{sliceName}	[delete]
func NetworkSliceSliceNameDelete(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNameDelete ")
	if ret := NetworkSliceDeleteHandler(c); ret {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// NetworkSliceSliceNamePost godoc
//
// @Description	Create a new network slice
// @Tags			Network Slices
// @Param			sliceName	path	string				true	" "
// @Param			content		body	configmodels.Slice	true	" "
// @Security		BearerAuth
// @Success		200	{object}	nil	"Network slice created"
// @Failure		400	{object}	nil	"Invalid network slice content"
// @Failure		401	{object}	nil	"Authorization failed"
// @Failure		403	{object}	nil	"Forbidden"
// @Failure		500	{object}	nil	"Error creating network slice"
// @Router			/config/v1/network-slice/{sliceName}	[post]
func NetworkSliceSliceNamePost(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePost ")
	if ret := NetworkSlicePostHandler(c, configmodels.Post_op); ret {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}

// NetworkSliceSliceNamePut -
func NetworkSliceSliceNamePut(c *gin.Context) {
	logger.ConfigLog.Debugf("Received NetworkSliceSliceNamePut ")
	if ret := NetworkSlicePostHandler(c, configmodels.Put_op); ret {
		c.JSON(http.StatusOK, gin.H{})
	} else {
		c.JSON(http.StatusBadRequest, gin.H{})
	}
}
